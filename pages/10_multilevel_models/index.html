<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Bayesian-Julia/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Bayesian-Julia/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Bayesian-Julia/css/jtd.css"> <link rel=icon  href="/Bayesian-Julia/assets/favicon.ico"> <title>Multilevel Models &#40;a.k.a. Hierarchical Models&#41;</title> <div class=page-wrap > <div class=side-bar > <div class=header > <a href="/Bayesian-Julia/" class=title > Bayesian Stats </a> </div> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/Bayesian-Julia/" class="menu-list-link ">Home</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/1_why_Julia/" class="menu-list-link ">1. Why Julia?</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/2_bayes_stats/" class="menu-list-link ">2. What is Bayesian Statistics?</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/3_prob_dist/" class="menu-list-link ">3. Common Probability Distributions</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/4_Turing/" class="menu-list-link ">4. How to use Turing</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/5_MCMC/" class="menu-list-link ">5. Markov Chain Monte Carlo (MCMC)</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/6_linear_reg/" class="menu-list-link ">6. Bayesian Linear Regression</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/7_logistic_reg/" class="menu-list-link ">7. Bayesian Logistic Regression</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/8_count_reg/" class="menu-list-link ">8. Bayesian Regression with Count Data</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/9_robust_reg/" class="menu-list-link ">9. Robust Bayesian Regression</a> <li class="menu-list-item active"><a href="/Bayesian-Julia/pages/10_multilevel_models/" class="menu-list-link active">10. Multilevel Models</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/11_Turing_tricks/" class="menu-list-link ">11. Computational Tricks with Turing</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/12_epi_models/" class="menu-list-link ">12. Bayesian Epidemiological Models</a> </ul> </div> <div class=footer > <a href="https://www.julialang.org"><img style="height:50px;padding-left:10px;margin-bottom:15px;" src="https://julialang.org/assets/infra/logo.svg" alt="Julia Logo"></a> </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <a id=github  href="https://github.com/storopoli/Bayesian-Julia">Code on GitHub</a> </div> <div class=franklin-content ><div class=franklin-toc ><ol><li><a href="#when_to_use_multilevel_models">When to use Multilevel Models?</a><li><a href="#hyperpriors">Hyperpriors</a><li><a href="#three_approaches_to_multilevel_models">Three Approaches to Multilevel Models</a><ol><li><a href="#random-intercept_model">Random-Intercept Model</a><li><a href="#random-slope_model">Random-Slope Model</a><li><a href="#random-intercept-slope_model">Random-Intercept-Slope Model</a></ol><li><a href="#example_-_cheese_ratings">Example - Cheese Ratings</a><li><a href="#references">References</a></ol></div> <h1 id=multilevel_models_aka_hierarchical_models ><a href="#multilevel_models_aka_hierarchical_models" class=header-anchor >Multilevel Models &#40;a.k.a. Hierarchical Models&#41;</a></h1> <p>Bayesian hierarchical models &#40;also called multilevel models&#41; are a statistical model written at <em>multiple</em> levels &#40;hierarchical form&#41; that estimates the parameters of the posterior distribution using the Bayesian approach. The sub-models combine to form the hierarchical model, and Bayes&#39; theorem is used to integrate them with the observed data and to account for all the uncertainty that is present. The result of this integration is the posterior distribution, also known as an updated probability estimate, as additional evidence of the likelihood function is integrated together with the prior distribution of the parameters.</p> <p>Hierarchical modeling is used when information is available at several different levels of observation units. The hierarchical form of analysis and organization helps to understand multiparameter problems and also plays an important role in the development of computational strategies.</p> <p>Hierarchical models are mathematical statements that involve several parameters, so that the estimates of some parameters depend significantly on the values of other parameters. The figure below shows a hierarchical model in which there is a \(\phi\) hyperparameter that parameterizes the parameters \(\theta_1, \theta_2, \dots, \theta_N\) that are finally used to infer the posterior density of some variable of interest \(\mathbf{y} = y_1, y_2, \dots, y_N\).</p> <p><img src="/Bayesian-Julia/pages/images/hierarchical.png" alt="Bayesian Workflow" /></p> <p><div class=text-center ><em>Hierarchical Model</em></div> <br/></p> <h2 id=when_to_use_multilevel_models ><a href="#when_to_use_multilevel_models" class=header-anchor >When to use Multilevel Models?</a></h2> <p>Multilevel models are particularly suitable for research projects where participant data is organized at more than one level, <em>i.e.</em> nested data. Units of analysis are usually individuals &#40;at a lower level&#41; that are nested in contextual/aggregate units &#40;at a higher level&#41;. An example is when we are measuring the performance of individuals and we have additional information about belonging to different groups such as sex, age group, hierarchical level, educational level or housing status.</p> <p>There is a main assumption that cannot be violated in multilevel models which is <strong>exchangeability</strong> &#40;de Finetti, 1974; Nau, 2001&#41;. Yes, this is the same assumption that we discussed in <a href="/Bayesian-Julia/pages/2_bayes_stats/">2. <strong>What is Bayesian Statistics?</strong></a>. This assumption assumes that groups are exchangeable. The figure below shows a graphical representation of the exchangeability. The groups shown as &quot;cups&quot; that contain observations shown as &quot;balls&quot;. If in the model&#39;s inferences, this assumption is violated, then multilevel models are not appropriate. This means that, since there is no theoretical justification to support exchangeability, the inferences of the multilevel model are not robust and the model can suffer from several pathologies and should not be used for any scientific or applied analysis.</p> <p><img src="/Bayesian-Julia/pages/images/exchangeability-1.png" alt="Bayesian Workflow" /> <img src="/Bayesian-Julia/pages/images/exchangeability-2.png" alt="Bayesian Workflow" /></p> <p><div class=text-center ><em>Exchangeability – Images from <a href="https://betanalpha.github.io/">Michael Betancourt</a></em></div> <br/></p> <h2 id=hyperpriors ><a href="#hyperpriors" class=header-anchor >Hyperpriors</a></h2> <p>As the priors of the parameters are sampled from another prior of the hyperparameter &#40;upper-level&#39;s parameter&#41;, which are called <strong>hyperpriors</strong>. This makes one group&#39;s estimates help the model to better estimate the other groups by providing more <strong>robust and stable estimates</strong>.</p> <p>We call the global parameters as <strong>population effects</strong> &#40;or population-level effects, also sometimes called fixed effects&#41; and the parameters of each group as <strong>group effects</strong> &#40;or group-level effects, also sometimes called random effects&#41;. That is why multilevel models are also known as mixed models in which we have both fixed effects and random effects.</p> <h2 id=three_approaches_to_multilevel_models ><a href="#three_approaches_to_multilevel_models" class=header-anchor >Three Approaches to Multilevel Models</a></h2> <p>Multilevel models generally fall into three approaches:</p> <ol> <li><p><strong>Random-intercept model</strong>: each group receives a <strong>different intercept</strong> in addition to the global intercept.</p> <li><p><strong>Random-slope model</strong>: each group receives <strong>different coefficients</strong> for each &#40;or a subset of&#41; independent variable&#40;s&#41; in addition to a global intercept.</p> <li><p><strong>Random-intercept-slope model</strong>: each group receives <strong>both a different intercept and different coefficients</strong> for each independent variable in addition to a global intercept.</p> </ol> <h3 id=random-intercept_model ><a href="#random-intercept_model" class=header-anchor >Random-Intercept Model</a></h3> <p>The first approach is the <strong>random-intercept model</strong> in which we specify a different intercept for each group, in addition to the global intercept. These group-level intercepts are sampled from a hyperprior.</p> <p>To illustrate a multilevel model, I will use the linear regression example with a Gaussian/normal likelihood function. Mathematically a Bayesian multilevel random-slope linear regression model is:</p> \[ \begin{aligned} \mathbf{y} &\sim \text{Normal}\left( \alpha + \alpha_j + \mathbf{X} \cdot \boldsymbol{\beta}, \sigma \right) \\ \alpha &\sim \text{Normal}(\mu_\alpha, \sigma_\alpha) \\ \alpha_j &\sim \text{Normal}(0, \tau) \\ \boldsymbol{\beta} &\sim \text{Normal}(\mu_{\boldsymbol{\beta}}, \sigma_{\boldsymbol{\beta}}) \\ \tau &\sim \text{Cauchy}^+(0, \psi_{\alpha})\\ \sigma &\sim \text{Exponential}(\lambda_\sigma) \end{aligned} \] <p>The priors on the global intercept \(\alpha\), global coefficients \(\boldsymbol{\beta}\) and error \(\sigma\), along with the Gaussian/normal likelihood on \(\mathbf{y}\) are the same as in the linear regression model. But now we have <strong>new parameters</strong>. The first are the <strong>group intercepts</strong> prior \(\alpha_j\) that denotes that every group \(1, 2, \dots, J\) has its own intercept sampled from a normal distribution centered on 0 with a standard deviation \(\psi_\alpha\). This group intercept is added to the linear predictor inside the Gaussian/normal likelihood function. The <strong>group intercepts&#39; standard deviation</strong> \(\tau\) have a hyperprior &#40;being a prior of a prior&#41; which is sampled from a positive-constrained Cauchy distribution &#40;a special case of the Student-\(t\) distribution with degrees of freedom \(\nu = 1\)&#41; with mean 0 and standard deviation \(\sigma_\alpha\). This makes the group-level intercept&#39;s dispersions being sampled from the same parameter \(\tau\) which allows the model to use information from one group intercept to infer robust information regarding another group&#39;s intercept dispersion and so on.</p> <p>This is easily accomplished with Turing:</p> <pre><code class=language-julia >using Turing
using Statistics: mean, std
using Random:seed&#33;
seed&#33;&#40;123&#41;

@model function varying_intercept&#40;X, idx, y; n_gr&#61;length&#40;unique&#40;idx&#41;&#41;, predictors&#61;size&#40;X, 2&#41;&#41;
    #priors
    α ~ Normal&#40;mean&#40;y&#41;, 2.5 * std&#40;y&#41;&#41;       # population-level intercept
    β ~ filldist&#40;Normal&#40;0, 2&#41;, predictors&#41;  # population-level coefficients
    σ ~ Exponential&#40;1 / std&#40;y&#41;&#41;             # residual SD
    #prior for variance of random intercepts
    #usually requires thoughtful specification
    τ ~ truncated&#40;Cauchy&#40;0, 2&#41;, 0, Inf&#41;     # group-level SDs intercepts
    αⱼ ~ filldist&#40;Normal&#40;0, τ&#41;, n_gr&#41;       # group-level intercepts

    #likelihood
    ŷ &#61; α .&#43; X * β .&#43; αⱼ&#91;idx&#93;
    y ~ MvNormal&#40;ŷ, σ&#41;
end;</code></pre> <h3 id=random-slope_model ><a href="#random-slope_model" class=header-anchor >Random-Slope Model</a></h3> <p>The second approach is the <strong>random-slope model</strong> in which we specify a different slope for each group, in addition to the global intercept. These group-level slopes are sampled from a hyperprior.</p> <p>To illustrate a multilevel model, I will use the linear regression example with a Gaussian/normal likelihood function. Mathematically a Bayesian multilevel random-slope linear regression model is:</p> \[ \begin{aligned} \mathbf{y} &\sim \text{Normal}\left( \alpha + \mathbf{X} \cdot \boldsymbol{\beta}_j \cdot \boldsymbol{\tau}, \sigma \right) \\ \alpha &\sim \text{Normal}(\mu_\alpha, \sigma_\alpha) \\ \boldsymbol{\beta}_j &\sim \text{Normal}(0, 1) \\ \boldsymbol{\tau} &\sim \text{Cauchy}^+(0, \psi_{\boldsymbol{\beta}})\\ \sigma &\sim \text{Exponential}(\lambda_\sigma) \end{aligned} \] <p>Here we have a similar situation from before with the same hyperprior, but now it is a hyperprior for the the group coefficients&#39; standard deviation prior: \(\boldsymbol{\beta}_j\). This makes the group-level coefficients&#39;s dispersions being sampled from the same parameter \(\tau\) which allows the model to use information from one group coefficients to infer robust information regarding another group&#39;s coefficients dispersion and so on.</p> <p>In Turing we can accomplish this as:</p> <pre><code class=language-julia >@model function varying_slope&#40;X, idx, y; n_gr&#61;length&#40;unique&#40;idx&#41;&#41;, predictors&#61;size&#40;X, 2&#41;&#41;
    #priors
    α ~ Normal&#40;mean&#40;y&#41;, 2.5 * std&#40;y&#41;&#41;                   # population-level intercept
    σ ~ Exponential&#40;1 / std&#40;y&#41;&#41;                         # residual SD
    #prior for variance of random slopes
    #usually requires thoughtful specification
    τ ~ filldist&#40;truncated&#40;Cauchy&#40;0, 2&#41;, 0, Inf&#41;, n_gr&#41; # group-level slopes SDs
    βⱼ ~ filldist&#40;Normal&#40;0, 1&#41;, predictors, n_gr&#41;       # group-level standard normal slopes

    #likelihood
    ŷ &#61; α .&#43; X * βⱼ * τ
    y ~ MvNormal&#40;ŷ, σ&#41;
end;</code></pre> <h3 id=random-intercept-slope_model ><a href="#random-intercept-slope_model" class=header-anchor >Random-Intercept-Slope Model</a></h3> <p>The third approach is the <strong>random-intercept-slope model</strong> in which we specify a different intercept and slope for each group, in addition to the global intercept. These group-level intercepts and slopes are sampled from hyperpriors.</p> <p>To illustrate a multilevel model, I will use the linear regression example with a Gaussian/normal likelihood function. Mathematically a Bayesian multilevel random-intercept-slope linear regression model is:</p> \[ \begin{aligned} \mathbf{y} &\sim \text{Normal}\left( \alpha + \alpha_j + \mathbf{X} \cdot \boldsymbol{\beta}_j \cdot \boldsymbol{\tau}_{\boldsymbol{\beta}}, \sigma \right) \\ \alpha &\sim \text{Normal}(\mu_\alpha, \sigma_\alpha) \\ \alpha_j &\sim \text{Normal}(0, \tau_{\alpha}) \\ \boldsymbol{\beta}_j &\sim \text{Normal}(0, 1) \\ \tau_{\alpha} &\sim \text{Cauchy}^+(0, \psi_{\alpha})\\ \boldsymbol{\tau}_{\boldsymbol{\beta}} &\sim \text{Cauchy}^+(0, \psi_{\boldsymbol{\beta}})\\ \sigma &\sim \text{Exponential}(\lambda_\sigma) \end{aligned} \] <p>Here we have a similar situation from before with the same hyperpriors, but now we fused both random-intercept and random-slope together.</p> <p>In Turing we can accomplish this as:</p> <pre><code class=language-julia >@model function varying_intercept_slope&#40;X, idx, y; n_gr&#61;length&#40;unique&#40;idx&#41;&#41;, predictors&#61;size&#40;X, 2&#41;&#41;
    #priors
    α ~ Normal&#40;mean&#40;y&#41;, 2.5 * std&#40;y&#41;&#41;                    # population-level intercept
    σ ~ Exponential&#40;1 / std&#40;y&#41;&#41;                          # residual SD
    #prior for variance of random intercepts and slopes
    #usually requires thoughtful specification
    τₐ ~ truncated&#40;Cauchy&#40;0, 2&#41;, 0, Inf&#41;                 # group-level SDs intercepts
    τᵦ ~ filldist&#40;truncated&#40;Cauchy&#40;0, 2&#41;, 0, Inf&#41;, n_gr&#41; # group-level slopes SDs
    αⱼ ~ filldist&#40;Normal&#40;0, τₐ&#41;, n_gr&#41;                   # group-level intercepts
    βⱼ ~ filldist&#40;Normal&#40;0, 1&#41;, predictors, n_gr&#41;        # group-level standard normal slopes

    #likelihood
    ŷ &#61; α .&#43; αⱼ&#91;idx&#93; .&#43; X * βⱼ * τᵦ
    y ~ MvNormal&#40;ŷ, σ&#41;
end;</code></pre> <h2 id=example_-_cheese_ratings ><a href="#example_-_cheese_ratings" class=header-anchor >Example - Cheese Ratings</a></h2> <p>For our example, I will use a famous dataset called <code>cheese</code> &#40;Boatwright, McCulloch &amp; Rossi, 1999&#41;, which is data from cheese ratings. A group of 10 rural and 10 urban raters rated 4 types of different cheeses &#40;A, B, C and D&#41; in two samples. So we have \(4 \cdot 20 \cdot2 = 160\) observations and 4 variables:</p> <ul> <li><p><code>cheese</code>: type of cheese from <code>A</code> to <code>D</code></p> <li><p><code>rater</code>: id of the rater from <code>1</code> to <code>10</code></p> <li><p><code>background</code>: type of rater, either <code>rural</code> or <code>urban</code></p> <li><p><code>y</code>: rating of the cheese</p> </ul> <p>Ok let&#39;s read our data with <code>CSV.jl</code> and output into a <code>DataFrame</code> from <code>DataFrames.jl</code>:</p> <pre><code class=language-julia >using DataFrames, CSV, HTTP

url &#61; &quot;https://raw.githubusercontent.com/storopoli/Bayesian-Julia/master/datasets/cheese.csv&quot;
cheese &#61; CSV.read&#40;HTTP.get&#40;url&#41;.body, DataFrame&#41;
describe&#40;cheese&#41;</code></pre><pre><code class="plaintext code-output">4×7 DataFrame
 Row │ variable    mean     min    median  max    nmissing  eltype
     │ Symbol      Union…   Any    Union…  Any    Int64     DataType
─────┼───────────────────────────────────────────────────────────────
   1 │ cheese               A              D             0  String1
   2 │ rater       5.5      1      5.5     10            0  Int64
   3 │ background           rural          urban         0  String7
   4 │ y           70.8438  33     71.5    91            0  Int64</code></pre> <p>As you can see from the <code>describe&#40;&#41;</code> output, the mean cheese ratings is around 70 ranging from 33 to 91.</p> <p>In order to prepare the data for Turing, I will convert the <code>String</code>s in variables <code>cheese</code> and <code>background</code> to <code>Int</code>s. Regarding <code>cheese</code>, I will create 4 dummy variables one for each cheese type; and <code>background</code> will be converted to integer data taking two values: one for each background type. My intent is to model <code>background</code> as a group both for intercept and coefficients. Take a look at how the data will look like for the first 5 observations:</p> <pre><code class=language-julia >for c in unique&#40;cheese&#91;:, :cheese&#93;&#41;
    cheese&#91;:, &quot;cheese_&#36;c&quot;&#93; &#61; ifelse.&#40;cheese&#91;:, :cheese&#93; .&#61;&#61; c, 1, 0&#41;
end

cheese&#91;:, :background_int&#93; &#61; map&#40;cheese&#91;:, :background&#93;&#41; do b
    b &#61;&#61; &quot;rural&quot; ? 1 :
    b &#61;&#61; &quot;urban&quot; ? 2 : missing
end

first&#40;cheese, 5&#41;</code></pre><pre><code class="plaintext code-output">5×9 DataFrame
 Row │ cheese   rater  background  y      cheese_A  cheese_B  cheese_C  cheese_D  background_int
     │ String1  Int64  String7     Int64  Int64     Int64     Int64     Int64     Int64
─────┼───────────────────────────────────────────────────────────────────────────────────────────
   1 │ A            1  rural          67         1         0         0         0               1
   2 │ A            1  rural          66         1         0         0         0               1
   3 │ B            1  rural          51         0         1         0         0               1
   4 │ B            1  rural          53         0         1         0         0               1
   5 │ C            1  rural          75         0         0         1         0               1</code></pre> <p>Now let&#39;s us instantiate our model with the data. Here, I will specify a vector of <code>Int</code>s named <code>idx</code> to represent the different observations&#39; group memberships. This will be used by Turing when we index a parameter with the <code>idx</code>, <em>e.g.</em> <code>αⱼ&#91;idx&#93;</code>.</p> <pre><code class=language-julia >X &#61; Matrix&#40;select&#40;cheese, Between&#40;:cheese_A, :cheese_D&#41;&#41;&#41;;
y &#61; cheese&#91;:, :y&#93;;
idx &#61; cheese&#91;:, :background_int&#93;;</code></pre> <p>The first model is the <code>varying_intercept</code>:</p> <pre><code class=language-julia >model_intercept &#61; varying_intercept&#40;X, idx, y&#41;
chain_intercept &#61; sample&#40;model_intercept, NUTS&#40;&#41;, MCMCThreads&#40;&#41;, 2_000, 4&#41;
summarystats&#40;chain_intercept&#41;  |&gt; DataFrame  |&gt; println</code></pre><pre><code class="plaintext code-output">9×8 DataFrame
 Row │ parameters  mean       std        naive_se    mcse        ess      rhat     ess_per_sec
     │ Symbol      Float64    Float64    Float64     Float64     Float64  Float64  Float64
─────┼─────────────────────────────────────────────────────────────────────────────────────────
   1 │ α            70.9301    5.54432   0.0619874   0.151922    1324.56  1.00412      27.5893
   2 │ β[1]          3.2586    1.25176   0.0139951   0.021452    3382.98  1.0008       70.4641
   3 │ β[2]        -11.5902    1.24205   0.0138866   0.0229192   3221.01  1.00152      67.0904
   4 │ β[3]          7.19031   1.26691   0.0141645   0.0212411   3486.68  1.00017      72.6241
   5 │ β[4]          1.2292    1.25872   0.0140729   0.0209321   3462.55  1.00082      72.1215
   6 │ σ             6.00084   0.276295  0.00308907  0.00373951  5598.17  1.00015     116.604
   7 │ τ             6.80095  10.8533    0.121344    0.290596    1333.35  1.00354      27.7722
   8 │ αⱼ[1]        -3.69408   5.46842   0.0611388   0.151203    1294.51  1.00427      26.9633
   9 │ αⱼ[2]         3.48534   5.46443   0.0610941   0.152707    1300.57  1.00434      27.0896
</code></pre> <p>Here we can see that the model has a population-level intercept <code>α</code> along with population-level coefficients <code>β</code>s for each <code>cheese</code> dummy variable. But notice that we have also group-level intercepts for each of the groups <code>αⱼ</code>s. Specifically, <code>αⱼ&#91;1&#93;</code> are the rural raters and <code>αⱼ&#91;2&#93;</code> are the urban raters.</p> <p>Now let&#39;s go to the second model, <code>varying_slope</code>:</p> <pre><code class=language-julia >model_slope &#61; varying_slope&#40;X, idx, y&#41;
chain_slope &#61; sample&#40;model_slope, NUTS&#40;&#41;, MCMCThreads&#40;&#41;, 2_000, 4&#41;
summarystats&#40;chain_slope&#41;  |&gt; DataFrame  |&gt; println</code></pre><pre><code class="plaintext code-output">12×8 DataFrame
 Row │ parameters  mean       std       naive_se    mcse        ess      rhat     ess_per_sec
     │ Symbol      Float64    Float64   Float64     Float64     Float64  Float64  Float64
─────┼────────────────────────────────────────────────────────────────────────────────────────
   1 │ α           70.8046    4.8548    0.0542783   0.126763    1516.38  1.00103      15.3348
   2 │ σ            6.53906   0.284046  0.00317573  0.00378025  5124.97  1.0006       51.8276
   3 │ τ[1]         5.94775   4.92371   0.0550488   0.130068    1263.75  1.00241      12.78
   4 │ τ[2]         6.22659   5.08161   0.0568141   0.129348    1267.83  1.00229      12.8213
   5 │ βⱼ[1,1]      0.25609   0.814328  0.00910447  0.0138938   3035.55  1.00156      30.6978
   6 │ βⱼ[2,1]     -0.918362  1.03272   0.0115462   0.0231148   1908.21  1.00114      19.2972
   7 │ βⱼ[3,1]      0.567697  0.899939  0.0100616   0.0186735   2355.99  1.00155      23.8255
   8 │ βⱼ[4,1]      0.108333  0.807913  0.00903274  0.0156147   2901.96  1.00063      29.3468
   9 │ βⱼ[1,2]      0.2613    0.793019  0.00886622  0.0135415   2435.88  1.00142      24.6334
  10 │ βⱼ[2,2]     -0.952107  1.02878   0.0115021   0.0253741   1676.97  1.00201      16.9588
  11 │ βⱼ[3,2]      0.584581  0.868181  0.00970656  0.0168627   2134.98  1.00073      21.5905
  12 │ βⱼ[4,2]      0.110568  0.784373  0.00876956  0.0145472   2688.16  1.00124      27.1847
</code></pre> <p>Here we can see that the model has still a population-level intercept <code>α</code>. But now our population-level coefficients <code>β</code>s are replaced by group-level coefficients <code>βⱼ</code>s along with their standard deviation <code>τᵦ</code>s. Specifically <code>βⱼ</code>&#39;s first index denotes the 4 dummy <code>cheese</code> variables&#39; and the second index are the group membership. So, for example <code>βⱼ&#91;1,1&#93;</code> is the coefficient for <code>cheese_A</code> and rural raters &#40;group 1&#41;.</p> <p>Now let&#39;s go to the third model, <code>varying_intercept_slope</code>:</p> <pre><code class=language-julia >model_intercept_slope &#61; varying_intercept_slope&#40;X, idx, y&#41;
chain_intercept_slope &#61; sample&#40;model_intercept_slope, NUTS&#40;&#41;, MCMCThreads&#40;&#41;, 2_000, 4&#41;
summarystats&#40;chain_intercept_slope&#41;  |&gt; DataFrame  |&gt; println</code></pre><pre><code class="plaintext code-output">15×8 DataFrame
 Row │ parameters  mean        std       naive_se    mcse        ess       rhat      ess_per_sec
     │ Symbol      Float64     Float64   Float64     Float64     Float64   Float64   Float64
─────┼───────────────────────────────────────────────────────────────────────────────────────────
   1 │ α           70.8662     7.05111   0.0788338   0.167632    1562.74   1.00128       8.95212
   2 │ σ            5.87408    0.26124   0.00292075  0.00390364  5354.71   1.00002      30.6743
   3 │ τₐ           6.26409    5.67725   0.0634736   0.132424    1858.87   1.00072      10.6485
   4 │ τᵦ[1]        6.41136    5.54969   0.0620474   0.194213     693.124  1.00677       3.97053
   5 │ τᵦ[2]        6.01462    5.14783   0.0575545   0.142421    1416.29   1.00214       8.11317
   6 │ αⱼ[1]       -3.53706    5.10246   0.0570472   0.142711    1332.97   1.00063       7.63585
   7 │ αⱼ[2]        3.63623    5.11268   0.0571615   0.143755    1330.09   1.00065       7.61935
   8 │ βⱼ[1,1]      0.251888   0.810363  0.00906013  0.0134701   3599.25   1.00017      20.6182
   9 │ βⱼ[2,1]     -0.932587   1.04589   0.0116934   0.0223825   2193.4    1.00134      12.5648
  10 │ βⱼ[3,1]      0.550215   0.88696   0.00991652  0.0175612   3040.82   1.00065      17.4192
  11 │ βⱼ[4,1]      0.0907195  0.786621  0.00879469  0.0106287   3975.37   0.999828     22.7728
  12 │ βⱼ[1,2]      0.256108   0.796045  0.00890005  0.0131822   3929.01   0.999837     22.5072
  13 │ βⱼ[2,2]     -0.899985   1.04917   0.01173     0.0251456   2070.99   1.00068      11.8636
  14 │ βⱼ[3,2]      0.552352   0.94327   0.0105461   0.0252117   1372.29   1.00242       7.86112
  15 │ βⱼ[4,2]      0.0911885  0.786055  0.00878836  0.0128445   3416.19   1.0014       19.5695
</code></pre> <p>Now we have fused the previous model in one. We still have a population-level intercept <code>α</code>. But now we have in the same model group-level intercepts for each of the groups <code>αⱼ</code>s and group-level along with their standard deviation <code>τₐ</code>. We also have the coefficients <code>βⱼ</code>s with their standard deviation <code>τᵦ</code>s. The parameters are interpreted exactly as the previous cases.</p> <h2 id=references ><a href="#references" class=header-anchor >References</a></h2> <p>Boatwright, P., McCulloch, R., &amp; Rossi, P. &#40;1999&#41;. Account-level modeling for trade promotion: An application of a constrained parameter hierarchical model. Journal of the American Statistical Association, 94&#40;448&#41;, 1063–1073.</p> <p>de Finetti, B. &#40;1974&#41;. Theory of Probability &#40;Volume 1&#41;. New York: John Wiley &amp; Sons.</p> <p>Nau, R. F. &#40;2001&#41;. De Finetti was Right: Probability Does Not Exist. Theory and Decision, 51&#40;2&#41;, 89–124. https://doi.org/10.1023/A:1015525808214</p> <div class=page-foot > <div class=copyright > Last modified: March 25, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap--> <script src="/Bayesian-Julia/libs/katex/katex.min.js"></script> <script src="/Bayesian-Julia/libs/katex/auto-render.min.js"></script> <script>renderMathInElement(document.body)</script> <script src="/Bayesian-Julia/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script>